# 返回后序遍历的第 K 个节点，时间复杂度不超过 x 的深度，Ο(depth(x))  (7+3+4 = 14) 

```c++

struct BinNode{ 
	int size; //当前节点和孩⼦总数
	BinNode *lchild,*rchild; 
}; 
BinNode *rank(BinNode* t,int k){ 
//有效代码⾏数不超过 12 ⾏
//不要尝试模拟后序遍历，时间复杂度会超时。
}
```
+ 1.给出具体算法实现。
+ 2.解释你的算法。
+ 3.分析时间复杂度和空间复杂度。

+ 绘制如下图表示遍历顺序

![2019](../images/2019.png)
+ 不难写出如下代码

```c++
BinNode * rank(BinNode *t ,int k){
    if(!t || t->size < k) return NULL;//如果是为空树或者全树的规模小于k则返回NULL

    if(t->size == k ) return size; //K刚好为全树的规模根据后续遍历的特点返回根节点

    if(!t->lc) return rank(t->rc, k);//没有左子树则直接到右子树中搜索

    int lsize  = t->lc->size;

    if(lszie >= k)  return rank(t->lc , k);//k小于左子树规模直接在左子树中查找
    else return rank(t->rc,k - lszie);//否则到右子树中查找在此之前必然已经跳过左子树规模
}
```
+ 算法解释在代码注释中

+ 复杂度正比于全树高度o(depth(x)) 空间复杂度o(1)
